---
output:
  html_document: default
  word_document: default
  pdf_document: default
---
```{r knitr_setup, echo=FALSE, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(cache=FALSE)
library(tidyverse)
library(dplyr)
library(tidyr)
library(ggplot2)
library(randomForest)
```

## An Analysis of Roger Federer, Rafael Nadal and Novak Djokovic

### Background
Currently, tennis is experiencing the end of a "Golden Age". Right now, there are three all time greats competing at the highest stage; all while being at the closing door of their careers. These three are Roger Federer, Rafael Nadal and Novak Djokovic. 

Roger Federer is a Swiss Tennis Player that is widely considered the greatest of all time (GOAT). He has won 20 Grand Slam titles, which is the most in history for ATP players. Additionally, he has broken countless ATP records, won many sports awards and is considered a fan favorite across the world. Even at the age of 36, Roger Federer is still at the top of the rankings and continues to be a strong contender for all of the biggest tournaments. You can look at his career statistics here:

https://en.wikipedia.org/wiki/Roger_Federer_career_statistics

Rafael Nadal is a Spanish Tennis player that is considered the other main contender for greatest of all time status. He has won 16 Grand Slam titles, which is the second most in ATP history. He is considered the greatest clay court player of all time and is another massively popular tennis player, just like Federer. At the age of 31, Rafael Nadal has shown no signs of slowing down, and is at the top of the rankings alongside Roger Federer even in 2018. You can look at his career statistics here:

https://en.wikipedia.org/wiki/Rafael_Nadal_career_statistics

Novak Djokovic is a Serbian Tennis Player that is well known for usurping the top spot of the rankings from Federer and Nadal. He is the youngest of the three, and after playing 3rd fiddle to Federer and Nadal, burst on to the scene in 2011 to take the crown at the top and completely dominate the tour at unprecedented levels from 2011 to 2016. He has won 12 Grand Slam titles, which puts him below Federer and Nadal, but made him a definite threat to their legacy for sure. He is currently recovering from surgery at the moment, but could return into grand slam winning form in some time. You can look at his career statistics here:

https://en.wikipedia.org/wiki/Novak_Djokovic_career_statistics

This tutorial will take you through the entire data science pipeline, as we explore the performance of these three all time greats throughout their careers.


### Required Tools

You will need to download R, as well as the following packages:

- tidyverse
- dplyr
- tidyr
- ggplot2
- randomForest

We recommend that you use RStudio to interact with R. RStudio is an environment that makes it easier for us to install the packages above and allows us to better perform data analysis with R.

R can be installed here:

https://cran.r-project.org/index.html 

### Gathering and Tidying The Data
First we need to gather data for tennis matches. We can find all ATP Men's matches from 2000 to 2016 at this link:

https://www.kaggle.com/jordangoblet/atp-tour-20002016

This will be formatted as a CSV or Comma-Separated Values File. We have to load this data using: read.csv

For Tennis Fans: It is important to note that Federer and Nadal have won many many matches in 2017 and 2018 and are currently ranked number 1 and 2 right now. This data will be missing and not be included in the study due to the years not being covered in the dataset.

As you can see below, we have loaded the data into a data frame.

```{r load_data, message=FALSE}
tennis <- read.csv("/Users/Devin/Documents/Data.csv")
head(tennis)
```

Let's look at this data a little bit:

- There are a total of 54 columns
- The ATP attribute represents the gameweek, there are 37 "weeks" of tournaments each year (Some tournaments are two weeks)
- We have tournament details like the Location, Tournament Name, Series, Court, Surface
- We have match details like the Date of Match, Round, Winner, Loser, Rankings, Scores, etc
- Missing data is indicated as NA

Now, of the 54 columns/attributes, there are quite a few that we do not really need. Let's tidy the data by making the dataframe cleaner, with only attributes that we plan on using:

- We do not need the location, since that informtion will not be necessary for this analysis since players pick and choose the tournaments they enter.
- We do not need the court type because most courts are outdoor and this analysis will not cover whether or not the court is outdoor or indoor (because we have a lot of more important things to analyze)
- We can safely get rid of a lot of the extra match stats like UBW, UBL, etc since those are match specific stats that aren't picked up for most tournaments.
- These are the match attributes we need: Round, Winner, Loser, WRank, LRank, W1, L1, W2, L2, W3, L3, W4, L4, W5, L5, WSets, LSets
- For those that are OCD, rename best.of to BestOf, Wsets to WSets, and Lsets to LSets, so they follow a common naming standard.

```{r}
tennis <- tennis %>%
  dplyr::select(Tournament, Date, Surface, Best.of, Series, Round, Winner, Loser, WRank, LRank, W1, L1, W2, L2, W3, L3, W4, L4, W5, L5, Wsets, Lsets) %>%
  rename(BestOf = Best.of) %>%
  rename(WSets = Wsets) %>%
  rename(LSets = Lsets)
head(tennis)
```

Now, our data frame is smaller and easier to view, since it contains only attributes we care about. Now we having to handle missing data.

As mentioned earlier, missing data is labeled as NA. NA values can be quite a pain to deal with when performing calculations and other functions, so let's take care of it. 

- Some players do not have a ranking, so we must replace their ranking value of NA with 1000. We can check if LRank is N/A and replace that with the value 1000. To do this, we need to convert WRank and LRank to numeric typing.
- Some matches did not play a specific set (Due to injuries, etc), so we must replace those set scores with 0. We can check W1-W5 and L1-L5 for N/A values and replace with 0. These attributes are already numeric typing so we don't have to change the typing.
- There are other ways to handle missing data other than what we just did. To learn more, check out this link here: https://www.statmethods.net/input/missingdata.html

```{r}
tennis$WRank <- suppressWarnings(as.numeric(as.character(tennis$WRank)))
tennis$LRank <- suppressWarnings(as.numeric(as.character(tennis$LRank)))
tennis$LRank[is.na(tennis$LRank)] <- as.factor(1000)

tennis$W1[is.na(tennis$W1)] <- 0
tennis$L1[is.na(tennis$L1)] <- 0
tennis$W2[is.na(tennis$W2)] <- 0
tennis$L2[is.na(tennis$L2)] <- 0
tennis$W3[is.na(tennis$W3)] <- 0
tennis$L3[is.na(tennis$L3)] <- 0
tennis$W4[is.na(tennis$W4)] <- 0
tennis$L4[is.na(tennis$L4)] <- 0
tennis$W5[is.na(tennis$W5)] <- 0
tennis$L5[is.na(tennis$L5)] <- 0

head(tennis)
```

Now, there are a couple of attributes that could be useful but don't yet exist in this data frame. Let's see if we can add them by making a few calculations:

- The first will be what we call a rank differential. It is the losing players rank minus the winning players rank. This attribute will be used to determine how big of an upset, rankwise, some matches are. The lower the value is in the negatives, the more of an upset the match was. 
- The second is the number of games won by the winner. We can calculate this by adding up the scores of W1-W5
- The third is the number of games won by the loser. We can calculate this by adding up the scores of L1-L5
- The fourth is Year. We are simply going to cut off the year from the Date attribute. This will help with grouping later on.

```{r, message=FALSE}
tennis <- tennis %>%
  mutate(Differential = LRank - WRank) %>%
  mutate(WGames = W1 + W2 + W3 + W4 + W5) %>%
  mutate(LGames = L1 + L2 + L3 + L4 + L5) %>%
  mutate(Year = format(as.Date(tennis$Date, format="%d/%m/%Y"),"%Y")) %>%
  select(Tournament, Year, Date, Surface, BestOf, Series, Round, Winner, Loser, WRank, LRank, Differential, W1, L1, W2, L2, W3, L3, W4, L4, W5, L5, WSets, LSets, WGames, LGames) 
head(tennis)
```

Now, let's get the individual matches for each player we are interested in. We will make individual data frames for Roger Federer, Rafael Nadal and Novak Djokovic, respectively.

We can use filter to grab all matches where Roger Federer, Rafael Nadal or Novak Djokovic was either the winner or loser, depending on which player the data frame is for. We will be using these three data frames for a lot of analysis to come.

```{r}
rfMatches <- tennis %>%
  filter(Winner == "Federer R." | Loser == "Federer R.")
head(rfMatches)

rnMatches <- tennis %>%
  filter(Winner == "Nadal R." | Loser == "Nadal R.")
head(rnMatches)

ndMatches <- tennis %>%
  filter(Winner == "Djokovic N." | Loser == "Djokovic N.")
head(ndMatches)
```

### Exploratory Data Analysis
Now that we have our data properly prepared. Let's analyze it. The purpose of our analysis is to get more information about patterns we see in our data.

Before we begin our analysis, let's quickly dive into the concepts of grouping and summarizing:

- The goal of grouping is to put entities into a group with the same value of one or more attributes. So if we were to group entities by year, we would put all entities with the same "Year" attribute in one group.
- It's important to note that when we group entities, all subsequent operations are then performed for each group independently, rather than the dataset as a whole.
- This is where summarizing comes in: After grouping, the summarize operation simply takes each group and calls a summary function on that group, performing a calculation that collapses the data frame into one neat row with the result of that calculation.

Sometimes it's better to just see rather than hear about it, so let's go to an example:

- The main cornerstone of being an all time great, is being able to consistently beat top ranked players. So, let's look at how each of our all time greats perform against top 20 ranked players. 

So, to do this, we are going to take the data frame with our respective player's winning matches and filter out all losing players with a rank greater than 20 (Which in the case of tennis, would be a worse rank). Then, we use the group_by operation to group each data frame by year so that we can later plot our player's top 20 wins per yearly season. You can read more about the group_by operation in R via its documentation here:

https://www.rdocumentation.org/packages/dplyr/versions/0.7.3/topics/group_by

After we have the groups, we can summarize these wins by using the n function to calculate the number of top 20 wins each player had for each season/group. You can read more about the summarize operation in R here:

https://www.rdocumentation.org/packages/Hmisc/versions/4.1-1/topics/summarize

The n function simply gives the number of entities in the group. You can read its documentation here:

https://www.rdocumentation.org/packages/dplyr/versions/0.7.3/topics/n

Now, for each player's data frame, we need to add a Player attribute to help us distinguish which player came from which data frame. Then, we bind or combine the three data frames together using rbind. 

Lastly, we can use ggplot to plot a bar graph that displays each player's Top 20 wins side by side for each year. You can learn more about ggplot here:

http://ggplot.yhathq.com/how-it-works.html

Let's quickly go over why I will use a bar graph for this:

- We will use a bar graph in order to see the relationship between two things: Top 20 Wins and Player Name. 
- We want to see which player: Federer, Nadal or Djokovic, had more Top 20 wins. 
- The length of the bars will help us better compare the differences between each player's Top 20 wins.
- However, our X-Axis is Year instead of Player Name due to the context of our plot. Each yearly season in tennis is very different from the last, which is why we want to compare each player's top 20 wins in the context of the year they ocurred. This is why we grouped our data by year and made our X-Axis the Year attribute.

```{r}
rfTop20 <- rfMatches %>%
  filter(Winner == "Federer R.") %>%
  filter(LRank <= 20) %>%
  group_by(Year) %>%
  summarize(top20Wins = n()) %>%
  mutate(Player = "Federer")

rnTop20 <- rnMatches %>%
  filter(Winner == "Nadal R.") %>%
  filter(LRank <= 20) %>%
  group_by(Year) %>%
  summarize(top20Wins = n()) %>%
  mutate(Player = "Nadal")

ndTop20 <- ndMatches %>%
  filter(Winner == "Djokovic N.") %>%
  filter(LRank <= 20) %>%
  group_by(Year) %>%
  summarize(top20Wins = n()) %>%
  mutate(Player = "Djokovic")

top20 <- rbind(rfTop20, rnTop20, ndTop20)
  
ggplot(top20, mapping = aes(x=Year, y=top20Wins)) + 
  geom_bar(aes(fill = Player), position = "dodge", stat="identity") + 
  ggtitle("Top 20 Wins Per Year") + 
  ylab("Top 20 Wins") + xlab("Year") +
  scale_fill_manual(values=c("#999999", "#56B4E9", "#E69F00"))
  
```

Let's analyze this plot:

- We notice that Djokovic has one year, 2015, where he had over 40 top 20 wins. This was his most dominant year (And the most dominant year for any player in history; Djokovic won most of the tournaments he entered that year and rarely lost)
- We also notice that Federer has great longevity, being able to consistently get more than 20 top20 wins for 10 different years. To compare, Nadal has more than 20 top20 wins in 4 years, while Djokovic has more than 20 top20 wins in 7 different years.
- We can also see the effect each player has on each other. Federer had a lot of top 20 wins in 2004-2007, but as Nadal and Djokovic started improving in 2008-2016, Federer's amount of wins decreased in the later years.

As we can see in the plot above, Nadal looks relatively unimpressive compared to Federer and Djokovic, but he is considered the greatest clay court player of all time. Let's analyze wins by surface type to see if this is true.

First, let's take the data frames and filter for all wins. We will also group by surface. 

After we have the groups, we can summarize these wins by using the n function to calculate the wins per surface for each player. For each player's data frame, we need to add a Player attribute to help us distinguish which player came from which data frame. Then, we can bind or combine the three data frames together.

Lastly, we use ggplot to plot a bar graph that displays each player's surface wins side by side.

Let's quickly go over why I will use a bar graph for this:

- We will use a bar graph in order to see the relationship between two things: Wins and Player Name
- We want to see which player: Federer, Nadal or Djokovic, had more wins
- The length of the bars will help us better compare the differences between each player's wins.
- However, our X-Axis is Surface instead of Player Name due to the context of our plot. We want to compare each player's wins in the context of the surface they were on. This is why we grouped our data by surface and made our X-Axis the Surface attribute.

```{r}
rfSurface <- rfMatches %>%
  filter(Winner == "Federer R.") %>%
  group_by(Surface) %>%
  summarize(surfaceWins = n()) %>%
  mutate(Player = "Federer")

rnSurface <- rnMatches %>%
  filter(Winner == "Nadal R.") %>%
  group_by(Surface) %>%
  summarize(surfaceWins = n()) %>%
  mutate(Player = "Nadal")

ndSurface <- ndMatches %>%
  filter(Winner == "Djokovic N.") %>%
  group_by(Surface) %>%
  summarize(surfaceWins = n()) %>%
  mutate(Player = "Djokovic")

surface <- rbind(rfSurface, rnSurface, ndSurface)

ggplot(surface, mapping = aes(x=Surface, y=surfaceWins)) + 
  geom_bar(aes(fill = Player), position = "dodge", stat="identity") + 
  ggtitle("Wins By Surface") + 
  ylab("Wins") + xlab("Surface") +
  scale_fill_manual(values=c("#999999", "#56B4E9", "#E69F00"))
```

Let's analyze this plot:

- Notice that Rafael Nadal does have the most wins on clay by far. He is leading Djokovic and Federer by a large margin.
- Just as Nadal has the most wins on clay, Federer has by far the most wins on Grass, doubling Djokovic and Nadal. These numbers are relatively low because there aren't many grass tournaments as there are clay and hard.
- Carpet was a surface that was discontinued in the late 2000s, so most players do not have many wins on Carpet. Federer has more wins than Djokovic and Nadal on Carpet because he is older and was playing more before Carpet's discontinuation.
- Hard courts are the most common surface, so it makes sense that each player would have the most wins on that surface.

One of the biggest contributors to the GOAT (Greatest of All Time) status are Grand Slam tournaments. There are four Grand Slam tournaments each year. These four tournaments, are the most prestigious tournaments in tennis and winning the trophy at one of these four tournaments is considered a great achievement. In the last 12 years, there were only 7 different grand slam champions. Roger Federer, Rafael Nadal and Novak Djokovic have held a sustained period of dominance over grand slams, winning a combined 48 out of the last 59 slams. (Federer winning 20, Nadal winning 16, Djokovic winning 12). 

- Note, Federer and Nadal have won 3 and 2 grand slams, respectively, in 2017 and 2018. So, within the bounds of this dataset (Which ends in 2016), Federer has only 17 grand slam wins and Nadal has only 14 grand slam wins.

Let's look at the amount of grand slam wins each player has won.

First we need to filter out all tournaments with a series that is not "Grand Slam". 

Then, we need to group by tournament. Afterwards, we can summarize the groups using the n function to get all wins per slam, and add a Player attribute to help us distinguish which player came from which data frame. Then, we bind or combine the three data frames together.

Lastly, we use ggplot to plot a bar graph that displays each player's grand slam wins side by side.

Let's quickly go over why I will use a bar graph for this:

- We will use a bar graph in order to see the relationship between two things: Wins and Player Name
- We want to see which player: Federer, Nadal or Djokovic, had more wins.
- The length of the bars will help us better compare the differences between each player's wins.
- However, our X-Axis is Grand Slam instead of Player Name due to the context of our plot. We want to compare each player's wins in the context of the Grand Slam tournament they were playing. This is why we grouped our data by tournament and made our X-Axis the Grand Slam attribute.

```{r}
rfSlams <- rfMatches %>%
  filter(Winner == "Federer R.") %>%
  filter(Series == "Grand Slam") %>%
  group_by(Tournament) %>%
  summarize(slamWins = n()) %>%
  mutate(Player = "Federer")

rnSlams <- rnMatches %>%
  filter(Winner == "Nadal R.") %>%
  filter(Series == "Grand Slam") %>%
  group_by(Tournament) %>%
  summarize(slamWins = n()) %>%
  mutate(Player = "Nadal")

ndSlams <- ndMatches %>%
  filter(Winner == "Djokovic N.") %>%
  filter(Series == "Grand Slam") %>%
  group_by(Tournament) %>%
  summarize(slamWins = n()) %>%
  mutate(Player = "Djokovic")

slams <- rbind(rfSlams, rnSlams, ndSlams)

ggplot(slams, mapping = aes(x=Tournament, y=slamWins)) + 
  geom_bar(aes(fill = Player), position = "dodge", stat="identity") + 
  ggtitle("Grand Slam Wins") + 
  ylab("Wins") + xlab("Grand Slam") +
  scale_fill_manual(values=c("#999999", "#56B4E9", "#E69F00"))
```

Let's analyze this plot:

- Nadal has the most French Open wins, which makes sense because the French Open is on clay, his favorite surface.
- Federer has the most Wimbledon wins, which makes sense because Wimbledon is on grass, his favorite surface.
- Djokovic is relatively balanced, winning approximately the same amount of matches for each slam.
- Federer has the most wins for 3 out of the four slams, and the most wins overall. This makes sense because he has won the most grand slam titles, and has also been playing the longest.

So far we've only been looking at wins. However, every player has off days which can lead to losses. Let's look at wins with losses also factored in. We can do this by looking at win percentages. 

Now, the first and more important thing to note is that "Win Percentage" is not an attribute in our dataset. We have to calculate it ourselves.

First, we need to assign each match a value for whether or not it was a victory; 1 for win, 0 for loss. 

Then, we need to group by year. Afterwards, we can use the summarize operation to take the mean of the WonMatch attribute for each group in order to create the winPercentage for that year. We also can take the Season values in order to preserve the Year attribute after our summary collapses the data. 

Then, we can add a Player attribute to help us distinguish which player came from which data frame. Afterwards, we bind the three data frames together.

Lastly, we can use ggplot to plot a line graph that displays each player's win percentage over time.

Let's quickly go over why I will use a line graph for this:

- A line graph allows us to see how a variable performs over time. We can see the particular peaks and valleys of that variable which can allow us to make inferences on its performance.
- In this line graph, we are tracking how the win percentages of each player change over time.

```{r}
rfFinals <- rfMatches %>%
  mutate(WonMatch = ifelse(Winner == "Federer R.", 1, 0)) %>%
  mutate(Season = Year) %>%
  group_by(Year) %>%
  summarize(WinPercentage = mean(WonMatch), Season = median(as.numeric(Season))) %>%
  mutate(Player = "Federer") %>%
  select(Player, Season, WinPercentage)

rnFinals <- rnMatches %>%
  mutate(WonMatch = ifelse(Winner == "Nadal R.", 1, 0)) %>%
  mutate(Season = Year) %>%
  group_by(Year) %>%
  summarize(WinPercentage = mean(WonMatch), Season = median(as.numeric(Season))) %>%
  mutate(Player = "Nadal") %>%
  select(Player, Season, WinPercentage)

ndFinals <- ndMatches %>%
  mutate(WonMatch = ifelse(Winner == "Djokovic N.", 1, 0)) %>%
  mutate(Season = Year) %>%
  group_by(Year) %>%
  summarize(WinPercentage = mean(WonMatch), Season = median(as.numeric(Season))) %>%
  mutate(Player = "Djokovic") %>%
  select(Player, Season, WinPercentage)

finals <- rbind(rfFinals, rnFinals, ndFinals)

ggplot(finals, mapping = aes(x=Season, y=WinPercentage)) + 
  geom_line(aes(color = Player)) + 
  ggtitle("Win Percentage Over Time") + 
  ylab("Win Percentage") + xlab("Year") +
  scale_color_manual(values=c("#999999", "#56B4E9", "#E69F00"))
```

Let's analyze this plot:

- Federer and Djokovic both have 3 years where they had over a 0.9 win percentage
- In comparison, Nadal only had 1 year with over a 0.9 win percentage
- We can see that Federer's win percentage peaked in 2004-2006 and slowly moved downwards, likely due to Nadal (And then later Djokovic) rising through the ranks.
- All three players had relatively low win percentages in the early stages of their career, except Djokovic who had a REALLY low win percentage in the early stage of his career. This is because Djokovic was really young in 2004 and started his season towards the end of the year which did not give him many matches.

Now let's see how the Win Percentages would look if they are standardized. Standardizing simply takes each win percentage value and turns it into a numerical value based on it's variance. Positive numbers are above the mean, while negative numbers are below the mean.

To standardize, we follow this formula:
(winPercentage - meanWinPercentage) / sdPercentage

To learn more about standardizing values:

http://www.statisticshowto.com/standardized-values-examples/

So first, we need to find the mean and standard deviation of our win percentages. We can do this by using the summarize function and then assigning them to two variables.

Next, we can use mutate to create the standardized win percentage, using the formula above.

Then, we can plot a line graph of the standardized win percentages. Our reasoning for using a line graph is the same as above.

```{r}
newFinals <- finals %>%
  summarize(MeanPercentage = mean(WinPercentage), sdPercentage = sd(WinPercentage))

meanWinPercentage <-newFinals$MeanPercentage
sdPercentage <- newFinals$sdPercentage

standardized <- finals %>%
  mutate(standardizedPercentage = (WinPercentage - meanWinPercentage)/sdPercentage)

ggplot(standardized, mapping = aes(x=Season, y=standardizedPercentage)) + 
  geom_line(aes(color = Player)) + 
  ggtitle("Standardized Win Percentage Over Time") + 
  ylab("Standardized Win Percentage") + xlab("Year") +
  scale_color_manual(values=c("#999999", "#56B4E9", "#E69F00"))
```

Let's briefly analyze this plot:

- Djokovic is the only player who has standardized win percentage below -2
- Federer has three years where he had a standardized win percentage at 1 or above.
- Djokovic only had one year with a standardized win percentage of 1.
- Nadal did not break 1 in terms of standardized win percentages.
- Federer is the only player to have a standardized win percentage greater than 1.
- In general, the line graph looks very similar to the one before; it should because it's the same data.

Based on these last few plots, we can easily tell that Federer, Nadal and Djokovic in their primes did not lose very often. However, there are certain rare occasions where they get upset by a lower ranked player. Let's take a look at these upsets.

Remember the Match Differential attribute we created earlier? Well now we can finally use it. The match differential is a measure that determines how big of an upset the match was. For big upsets, let's look at all matches with a differential less than or equal to -100.

So let's take each data frame and use filter to get all matches where our player has lost a match with a differential less than or equal to -100. Then, lets bind all three data frames together.

```{r}
rfUpsets <- rfMatches %>%
  filter(Loser == "Federer R.") %>%
  filter(Differential <= -100)

rnUpsets <- rnMatches %>%
  filter(Loser == "Nadal R.") %>%
  filter(Differential <= -100)

ndUpsets <- ndMatches %>%
  filter(Loser == "Djokovic N.") %>%
  filter(Differential <= -100)

upsets <- rbind(rfUpsets, rnUpsets, ndUpsets)
upsets %>% select(Tournament, Year, Winner, Loser, Surface, Round, WRank, LRank, Differential)
```

Let's briefly analyze this table:

- Djokovic seems to get upset the least, having only 4 big upsets, to Nadal's 8 and Federer's 6.
- Nadal has the biggest upset, against Johansson, with a differential of -688, which is way lower than other differentials (The second lowest is -317, which was a match Djokovic lost against Krajinovic)
- I think the most important takeaway is how few upsets there are. Federer, Nadal and Djokovic play hundreds (Over 1000 for Federer) of matches, and only had 6, 8 and 4 big upsets, respectively. This stat is a testament to how consistently good these players are.

Despite there being some bad losses above, in most cases, a match that involves Federer, Nadal or Djokovic is very quick and easy for them. Let's analyze their dominant performances.

Let's define a dominant win as a win where the opponent has won 5 games or less. This means that Federer, Nadal, or Djokovic had to have won in straight sets by a great margin.

First, we need to filter out matches that do not result in a victory for our respective player. Then, we only keep matches where the loser got 5 games or less. Then, we used the summarize operation's n function to take the number of dominant matches for each player and add a Player attribute to help us distinguish which player came from which data frame. 

We also should make a separate data frame, that totals up all wins for each player, using a similar process. We want to do this so we can compare the dominant wins to the total wins. We can then join those two tables together. You can learn more about joins in R here:

https://www.rdocumentation.org/packages/plyr/versions/1.8.4/topics/join

Then, we bind the three data frames together and displayed as a table.

```{r}
dominantRF <- rfMatches %>%
  filter(Winner == "Federer R.") %>%
  filter(LGames <= 5) %>%
  summarize(DominantWins = n()) %>%
  mutate(Player = "Federer")

rfWins <- rfMatches %>%
  filter(Winner == "Federer R.") %>%
  summarize(TotalWins = n()) %>%
  mutate(Player = "Federer")

dominantRN <- rnMatches %>%
  filter(Winner == "Nadal R.") %>%
  filter(LGames <= 5) %>%
  summarize(DominantWins = n()) %>%
  mutate(Player = "Nadal")

rnWins <- rnMatches %>%
  filter(Winner == "Nadal R.") %>%
  summarize(TotalWins = n()) %>%
  mutate(Player = "Nadal")

dominantND <- ndMatches %>%
  filter(Winner == "Djokovic N.") %>%
  filter(LGames <= 5) %>%
  summarize(DominantWins = n()) %>%
  mutate(Player = "Djokovic")

ndWins <- ndMatches %>%
  filter(Winner == "Djokovic N.") %>%
  summarize(TotalWins = n()) %>%
  mutate(Player = "Djokovic")

dominantRF <- dominantRF %>%
  left_join(rfWins, by="Player")

dominantRN <- dominantRN %>%
  left_join(rnWins, by="Player")

dominantND <- dominantND %>%
  left_join(ndWins, by="Player")

dominant <- rbind(dominantRF, dominantRN, dominantND)
dominant %>% select(Player, TotalWins, DominantWins)
```

Let's briefly analyze this table:

- Nadal is the player with the most dominant wins
- Federer, despite having way more total wins, still has less dominant wins than Nadal.
- Djokovic is the youngest of the three, so he has the least total wins and dominant wins.

The results of our analysis will be in the "Messages" section at the end of our tutorial.

### Hypothesis Testing & Machine Learning

Machine learning is making predictions based on the patterns we find in data. For this tutorial, we are going to use something called supervised machine learning. We are going to train a predictor using a training dataset. We then will check how well this predictor predicts by using it on another dataset called the testing dataset. You can learn more about supervised machine learning from this link:

https://machinelearningmastery.com/supervised-and-unsupervised-machine-learning-algorithms/

The hypothesis we will test is: 

- Will Roger Federer win his next match with Rafael Nadal?

Before we start, we have to look for all matches between Federer and Nadal. 

To do this, we will take all of Federer's matches and use filter to get all matches with Nadal as the winner. Then, we will do it again and get every match with Nadal as the loser. Then we will combine the two data frames. We will only select a few attributes to keep the data relatively clean, like Year, Winner, WGames and LGames, since we're only focused on predicting results. We also need to give each row an ID.

Why Did We Select These Attributes:

- We need the Year to arrange our data in chronological order.
- We need the Winner for obvious reasons (We're predicting winners)
- We need WGames and LGames, the number of games won by the winner and won by the loser, to use as information to help fuel the predictions.

```{r}

fedalMatches <- rfMatches %>%
  filter(Winner == "Nadal R.") 

fedalMatches2 <- rfMatches %>%
  filter(Loser == "Nadal R.") 

fedal <- rbind(fedalMatches, fedalMatches2) %>%
  select(Year, Winner, WGames, LGames) %>%
  arrange(Year)

fedal$ID <- seq.int(nrow(fedal))

fedal

```

Now, we have a dataframe with outcomes for each match. What we need to do next is build a classifier for each outcome based on the predictors. 

First we have to create a Game Differential attribute: 
- It will be the number of games won by Federer, minus the number of games won by Nadal.
- So all matches won by Nadal are negative; matches won by Federer are positive.
- This differential attribute will help us make predictions
- Likewise, we switched the Winner attribute to a Prediction attribute so that we can better deal with typing.

```{r}

fedalPrepped <- fedal %>%
  mutate(Differential = ifelse(Winner == "Federer R.", WGames - LGames, LGames - WGames)) %>%
  mutate(Prediction = ifelse(Differential >= 0, "Federer", "Nadal")) %>%
  dplyr::select(ID, Prediction, Differential)

fedalPrepped$Prediction <- factor(fedalPrepped$Prediction)

fedalPrepped

```

Now, we need to split the prepped data into training and testing subsets. We can use sample_frac to get 20% of this data. Learn more about sample_frac here:

https://www.rdocumentation.org/packages/dplyr/versions/0.7.3/topics/sample


```{r}
set.seed(9989)

fedalTest <- fedalPrepped %>%
  group_by(Prediction) %>%
  sample_frac(.2) %>%
  ungroup()

fedalTest

fedalTrain <- fedalPrepped %>%
  anti_join(fedalTest, by="ID")

fedalTrain
```

Now that we have our testing and training data prepared, let's use a random forest to train our data. In order to learn what a random forest is, we have to learn what a decision tree is:

Decision trees are used in classification problems where the outcome is categorical (So in our case the categories are: Federer, Nadal). The tree would partition for each categorical prediction into regions, which predict the majority class for training observations within region.

Using a decision tree has several good properties:

- Decision trees are natural constructs, since the outcomes are categorical
- The models are invariant under transformations in the predictor space
- Tree growth is efficient
- Models go after interactions immediately
- Multi-factor responses are easily dealt with

However, there are a couple problems:

- Results can be variable
- Simple trees do not have a lot of predictive power
- Its a greedy algorithm, so the absolute best model may not be found

To solve these problems, We will train over a random forest. A Random Forest is a popular approach to address the shortcomings of singular decision trees by resampling the training data. The goal of a random forest is to improve prediction performance and reduce instability. A random forest averages multiple decision trees that were constructed using a subset of the training data and a subset of the attributes on which to split. So, instead of relying on one decision tree, we are relying on the average of many decision trees. 

To use a random forest, we will use a function from the package "randomForest", you can read more about that package here:

https://cran.r-project.org/web/packages/randomForest/randomForest.pdf

```{r, message=FALSE}
rf <- randomForest(Prediction~., data=fedalTrain %>% dplyr::select(-ID))
rf
```

Let's analyze exactly what these results mean:

- The Random Forest contains 500 trees.
- The estimated error rate is 3.7%, meaning that the tree wrongly predicted a false positive 3.7% of the time
- Our forest has correctly predicted Federer as the next winner 10 times
- Our forest has incorrectly predicted Federer as the winner once, when Nadal should've been the winner based on our data
- Our forest has correctly predicted Nadal as the next winner 16 times

So now, we let's make a confusion matrix taking into account both testing and training data. You can learn more about confusion matrices here:

http://www.dataschool.io/simple-guide-to-confusion-matrix-terminology/

```{r}
fedalPredictions <- predict(rf, newdata=fedalTest %>% dplyr::select(-ID))

table(pred=fedalPredictions, observed=fedalTest$Prediction)
```

Let's analyze exactly what these results mean:

- We predict Federer as the winner of the next match 3/7 times
- We predict Nadal as the winner of the next match 4/7 times

We will discuss the implications of these results in the next section.

### Concluding Message
Here are the results of our Exploratory Data Analysis:

- Most Top 20 Wins in One Season - Djokovic
- Most Wins on Grass Court - Federer
- Most Wins on Hard Court - Federer
- Most Wins on Clay Court - Nadal
- Most Australian Open Wins - Federer
- Most French Open Wins - Nadal
- Most Wimbledon Wins - Federer
- Most US Open Wins - Federer
- Highest Win Percentage for One Season - Federer
- Least Upsets - Djokovic
- Most Total Wins - Federer
- Most Dominant Wins - Nadal

We can see that Federer's name shows up the most in this list, which partially supports his claim to being the Greatest Of All Time. (He actually is, if we did more analysis, we'd find that his name would show up even more times. The man is truly the greatest of all time, and countless statistics support it). Anyways, it's good to see that our small sample analysis matches and comes to the same conclusion on who is the GOAT.

Here are the results of our Random Forest:

- Our Random Forest predicts Federer as the winner of the next match 38.46% of the time
- Our Random Forest predicts Nadal as the winner of the next match 61.54% of the time
- Our Random Forest error rate is 3.7%

After taking into account both the Random Forest trained data and our testing data:

- We predict Federer as the winner of the next match 42.86% of the time.
- We predict Nadal as the winner of the next match 57.14% of the time.

Based on our exploratory data analysis, Roger Federer tends to have the best results overall if we look at all of the tables/plots together. This supports the fact that he is the Greatest of All Time. However, if we were to take one of his rivals like Rafael Nadal and use machine learning to predict a winner, we would actually predict a loss for Roger Federer slightly more than we would a victory. This is because Rafael Nadal has a history of beating Roger Federer many times, so the data would support the prediction of Rafael Nadal beating Roger Federer.

Luckily for us, this data goes to 2016, which allows us to check if our predictions actually were correct:

- They weren't correct.
- Roger Federer has played Rafael Nadal 4 times in 2017 and won every single match, despite our predictions.

##### The main message to take away from all this is:

Although statistics and data analysis can be used to support the greatness of a tennis player based on his past results, the very best tennis players can find a way to prove stats wrong. Countless statisticians wrote off Roger Federer many years ago due to his losses to younger rivals like Rafael Nadal and Novak Djokovic. However, at the age of 36, Roger Federer was able to prove everyone wrong by turning the tables in 2017 and 2018 to win 3 more Grand Slams and beat Rafael Nadal 4 times in a row. 


### Sources

https://en.wikipedia.org/wiki/Roger_Federer_career_statistics

https://en.wikipedia.org/wiki/Rafael_Nadal_career_statistics

https://en.wikipedia.org/wiki/Novak_Djokovic_career_statistics

https://cran.r-project.org/index.html

https://www.kaggle.com/jordangoblet/atp-tour-20002016

https://www.statmethods.net/input/missingdata.html

https://www.rdocumentation.org/packages/dplyr/versions/0.7.3/topics/group_by

https://www.rdocumentation.org/packages/Hmisc/versions/4.1-1/topics/summarize

https://www.rdocumentation.org/packages/dplyr/versions/0.7.3/topics/n

http://ggplot.yhathq.com/how-it-works.html

http://www.statisticshowto.com/standardized-values-examples/

https://www.rdocumentation.org/packages/plyr/versions/1.8.4/topics/join

https://machinelearningmastery.com/supervised-and-unsupervised-machine-learning-algorithms/

https://www.rdocumentation.org/packages/dplyr/versions/0.7.3/topics/sample

https://cran.r-project.org/web/packages/randomForest/randomForest.pdf

http://www.dataschool.io/simple-guide-to-confusion-matrix-terminology/