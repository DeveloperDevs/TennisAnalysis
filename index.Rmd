---
output:
  html_document: default
  word_document: default
  pdf_document: default
---
```{r knitr_setup, echo=FALSE, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(cache=FALSE)
library(tidyverse)
library(dplyr)
library(tidyr)
library(ggplot2)
library(randomForest)
```

## An Analysis of Roger Federer, Rafael Nadal and Novak Djokovic

##### August 25th, 2018

### Background
Currently, tennis is experiencing the end of a "Golden Age". Right now, there are three all time greats competing at the highest stage; all while being at the closing door of their careers. These three are Roger Federer, Rafael Nadal and Novak Djokovic. 

Roger Federer is a Swiss Tennis Player that is widely considered the greatest of all time (GOAT). He has won 20 Grand Slam titles, which is the most in history for ATP players. Additionally, he has broken countless ATP records, won many sports awards and is considered a fan favorite across the world. Even at the age of 37, Roger Federer is still at the top of the rankings and continues to be a strong contender for all of the biggest tournaments. 

Rafael Nadal is a Spanish Tennis player that is considered the other main contender for greatest of all time status. He has won 16 Grand Slam titles, which is the second most in ATP history. He is considered the greatest clay court player of all time and is another massively popular tennis player, just like Federer. At the age of 32, Rafael Nadal has shown no signs of slowing down, and is at the top of the rankings alongside Roger Federer even in 2018. 

Novak Djokovic is a Serbian Tennis Player that is well known for usurping the top spot of the rankings from Federer and Nadal. He is the youngest of the three, and after playing 3rd fiddle to Federer and Nadal, burst on to the scene in 2011 to take the crown at the top and completely dominate the tour at unprecedented levels from 2011 to 2016. He has won 13 Grand Slam titles, which puts him below Federer and Nadal, but made him a legitimate threat to both of them in terms of the GOAT argument. After recovering from surgery in early 2018, he returned to grand slam winning form by Wimbledon later that year to win his 13th slam. 

Let's explore the performance of these three all time greats throughout their careers.

### Gathering and Tidying The Data
First we need to gather data for tennis matches. We can find all ATP Men's matches from 2000 to March 2018 at this link:

https://www.kaggle.com/edouardthomas/atp-matches-dataset

This will be formatted as a CSV or Comma-Separated Values File. We have to load this data using: read.csv

For Tennis Fans: It is important to note that matches after March 2018 are not included in the dataset; this includes Nadal's 2018 French Open victory and Djokovic's 2018 Wimbledon victory.

```{r load_data, message=FALSE}
tennis <- read.csv("/Users/datvuonglee/Desktop/Data.csv")
head(tennis)
```

Let's look at this data a little bit:

- There are a total of 23 columns
- The ATP attribute represents the gameweek, there are 37 "weeks" of tournaments each year (Some tournaments are two weeks)
- We have tournament details like the Location, Tournament Name, Series, Court, Surface
- We have match details like the Date of Match, Round, Winner, Loser, Rankings, Set Scores, ELO etc
- Missing data is indicated as NA

Now, of the 23 columns/attributes, there are a few that we do not really need. Let's tidy the data by making the dataframe cleaner, with only attributes that we plan on using:

- We do not need the location, since that informtion will not be necessary for this analysis since players pick and choose the tournaments they enter.
- We can safely get rid of a lot of the extra match stats like PSW, PSL, B365W, etc since those are stats that aren't picked up for most tournaments.
- We can rename a few attributes so that each attribute has a similar naming format.

```{r}
tennis <- tennis %>%
  dplyr::select(Tournament, Date, Surface, Best.of, Series, Court, Round, Winner, Loser, WRank, LRank, Wsets, Lsets, elo_winner, elo_loser) %>%
  rename(BestOf = Best.of) %>%
  rename(WSets = Wsets) %>%
  rename(LSets = Lsets) %>%
  rename(WElo = elo_winner) %>%
  rename(LElo = elo_loser)
head(tennis)
```

Now, our data frame is smaller and easier to view, since it contains only attributes we care about. Now we having to handle missing data.

As mentioned earlier, missing data is labeled as NA. NA values can be quite a pain to deal with when performing calculations and other functions, so let's take care of it. 

Some players do not have a ranking, so we must replace their ranking value of NA with 1000. We can check if LRank is N/A and replace that with the value 1000. To do this, we need to convert WRank and LRank to numeric typing.

```{r}
tennis$WRank <- suppressWarnings(as.numeric(as.character(tennis$WRank)))
tennis$LRank <- suppressWarnings(as.numeric(as.character(tennis$LRank)))
tennis$LRank[is.na(tennis$LRank)] <- as.factor(1000)

head(tennis)
```

Now, there are a couple of attributes that could be useful but don't yet exist in this data frame. Let's see if we can add them by making a few calculations:

- The first will be what we call a rank differential. It is the losing players rank minus the winning players rank. This attribute will be used to determine how big of an upset, rankwise, some matches are. The lower the value is in the negatives, the more of an upset the match was. 
- The second is Year. We are simply going to cut off the year from the Date attribute. This will help with grouping later on.

```{r, message=FALSE}
tennis <- tennis %>%
  mutate(Differential = LRank - WRank) %>%
  mutate(Year = format(as.Date(tennis$Date, format="%Y-%m-%d"),"%Y")) %>%
  select(Tournament, Year, Date, Surface, Court, BestOf, Series, Round, Winner, Loser, WRank, LRank, Differential, WSets, LSets, WElo, LElo) 
head(tennis)
```

Now, let's get the individual matches for each player we are interested in. We will make individual data frames for Roger Federer, Rafael Nadal and Novak Djokovic, respectively.

We can use filter to grab all matches where Roger Federer, Rafael Nadal or Novak Djokovic was either the winner or loser, depending on which player the data frame is for. We will be using these three data frames for a lot of analysis to come.

```{r}
rfMatches <- tennis %>%
  filter(Winner == "Federer R." | Loser == "Federer R.")
head(rfMatches)

rnMatches <- tennis %>%
  filter(Winner == "Nadal R." | Loser == "Nadal R.")
head(rnMatches)

ndMatches <- tennis %>%
  filter(Winner == "Djokovic N." | Loser == "Djokovic N.")
head(ndMatches)
```

### Exploratory Data Analysis
Now that we have our data properly prepared. Let's analyze it. The purpose of our analysis is to get more information about patterns we see in our data.

Before we begin our analysis, let's quickly dive into the concepts of grouping and summarizing:

- The goal of grouping is to put entities into a group with the same value of one or more attributes. So if we were to group entities by year, we would put all entities with the same "Year" attribute in one group.
- It's important to note that when we group entities, all subsequent operations are then performed for each group independently, rather than the dataset as a whole.
- This is where summarizing comes in: After grouping, the summarize operation simply takes each group and calls a summary function on that group, performing a calculation that collapses the data frame into one neat row with the result of that calculation.

Sometimes it's better to just see rather than hear about it, so let's go to an example:

##### Top 20 Wins

The main cornerstone of being an all time great, is being able to consistently beat top ranked players. So, let's look at how each of our all time greats perform against top 20 ranked players. 

So, to do this, we are going to take the data frame with our respective player's winning matches and filter out all losing players with a rank greater than 20 (Which in the case of tennis, would be a worse rank). Then, we use the group_by operation to group each data frame by year so that we can later plot our player's top 20 wins per yearly season. 

After we have the groups, we can summarize these wins by using the n function to calculate the number of top 20 wins each player had for each season/group. 

The n function simply gives the number of entities in the group. 

Now, for each player's data frame, we need to add a Player attribute to help us distinguish which player came from which data frame. Then, we bind or combine the three data frames together using rbind. 

Lastly, we can use ggplot to plot a bar graph that displays each player's Top 20 wins side by side for each year. 

Let's quickly go over why I will use a bar graph for this:

- We will use a bar graph in order to see the relationship between two things: Top 20 Wins and Player Name. 
- We want to see which player: Federer, Nadal or Djokovic, had more Top 20 wins. 
- The length of the bars will help us better compare the differences between each player's Top 20 wins.
- However, our X-Axis is Year instead of Player Name due to the context of our plot. Each yearly season in tennis is very different from the last, which is why we want to compare each player's top 20 wins in the context of the year they ocurred. This is why we grouped our data by year and made our X-Axis the Year attribute.

```{r}
rfTop20 <- rfMatches %>%
  filter(Winner == "Federer R.") %>%
  filter(LRank <= 20) %>%
  group_by(Year) %>%
  summarize(top20Wins = n()) %>%
  mutate(Player = "Federer")

rnTop20 <- rnMatches %>%
  filter(Winner == "Nadal R.") %>%
  filter(LRank <= 20) %>%
  group_by(Year) %>%
  summarize(top20Wins = n()) %>%
  mutate(Player = "Nadal")

ndTop20 <- ndMatches %>%
  filter(Winner == "Djokovic N.") %>%
  filter(LRank <= 20) %>%
  group_by(Year) %>%
  summarize(top20Wins = n()) %>%
  mutate(Player = "Djokovic")

top20 <- rbind(rfTop20, rnTop20, ndTop20)
  
ggplot(top20, mapping = aes(x=Year, y=top20Wins)) + 
  geom_bar(aes(fill = Player), position = "dodge", stat="identity") + 
  ggtitle("Top 20 Wins Per Year") + 
  ylab("Top 20 Wins") + xlab("Year") +
  scale_fill_manual(values=c("#999999", "#56B4E9", "#E69F00"))
  
```

Let's analyze this plot:

- We notice that Djokovic has one year, 2015, where he had over 40 top 20 wins. This was his most dominant year (And the most dominant year for any player in history; Djokovic won most of the tournaments he entered that year and rarely lost)
- We also notice that Federer has great longevity, being able to consistently get more than 20 top20 wins for 10 different years. To compare, Nadal has more than 20 top 20 wins in 5 years, while Djokovic has more than 20 top 20 wins in 7 different years.
- We can also see the effect each player has on each other. Federer had a lot of top 20 wins in 2004-2007, but as Nadal and Djokovic started improving in 2008-2016, Federer's amount of wins decreased in the later years.

##### Wins By Surface

As we can see in the plot above, Nadal looks relatively unimpressive compared to Federer and Djokovic, but he is considered the greatest clay court player of all time. Let's analyze wins by surface type to see if this is true.

First, let's take the data frames and filter for all wins. We will also group by surface. 

After we have the groups, we can summarize these wins by using the n function to calculate the wins per surface for each player. For each player's data frame, we need to add a Player attribute to help us distinguish which player came from which data frame. Then, we can bind or combine the three data frames together.

Lastly, we use ggplot to plot a bar graph that displays each player's surface wins side by side.

Let's quickly go over why I will use a bar graph for this:

- We will use a bar graph in order to see the relationship between two things: Wins and Player Name
- We want to see which player: Federer, Nadal or Djokovic, had more wins
- The length of the bars will help us better compare the differences between each player's wins.
- However, our X-Axis is Surface instead of Player Name due to the context of our plot. We want to compare each player's wins in the context of the surface they were on. This is why we grouped our data by surface and made our X-Axis the Surface attribute.

```{r}
rfSurface <- rfMatches %>%
  filter(Winner == "Federer R.") %>%
  group_by(Surface) %>%
  summarize(surfaceWins = n()) %>%
  mutate(Player = "Federer")

rnSurface <- rnMatches %>%
  filter(Winner == "Nadal R.") %>%
  group_by(Surface) %>%
  summarize(surfaceWins = n()) %>%
  mutate(Player = "Nadal")

ndSurface <- ndMatches %>%
  filter(Winner == "Djokovic N.") %>%
  group_by(Surface) %>%
  summarize(surfaceWins = n()) %>%
  mutate(Player = "Djokovic")

surface <- rbind(rfSurface, rnSurface, ndSurface)

ggplot(surface, mapping = aes(x=Surface, y=surfaceWins)) + 
  geom_bar(aes(fill = Player), position = "dodge", stat="identity") + 
  ggtitle("Wins By Surface") + 
  ylab("Wins") + xlab("Surface") +
  scale_fill_manual(values=c("#999999", "#56B4E9", "#E69F00"))
```

Let's analyze this plot:

- Notice that Rafael Nadal does have the most wins on clay by far. He is leading Djokovic and Federer by a large margin.
- Just as Nadal has the most wins on clay, Federer has by far the most wins on Grass, doubling Djokovic and Nadal. These numbers are relatively low because there aren't many grass tournaments as there are clay and hard.
- Carpet was a surface that was discontinued in the late 2000s, so most players do not have many wins on Carpet. Federer has more wins than Djokovic and Nadal on Carpet because he is older and was playing more before Carpet's discontinuation.
- Hard courts are the most common surface, so it makes sense that each player would have the most wins on that surface.

##### Indoor VS Outdoor Wins

Sometimes the surface isn't the only court condition that affects player's results. Indoor courts tend to be faster and allow the ball to penetrate through the air more. Let's see how this affects the all time greats by checking their amount of Indoor and Outdoor match wins.

```{r}
rfCourt <- rfMatches %>%
  filter(Winner == "Federer R.") %>%
  group_by(Court) %>%
  summarize(courtWins = n()) %>%
  mutate(Player = "Federer")

rnCourt <- rnMatches %>%
  filter(Winner == "Nadal R.") %>%
  group_by(Court) %>%
  summarize(courtWins = n()) %>%
  mutate(Player = "Nadal")

ndCourt <- ndMatches %>%
  filter(Winner == "Djokovic N.") %>%
  group_by(Court) %>%
  summarize(courtWins = n()) %>%
  mutate(Player = "Djokovic")

court <- rbind(rfCourt, rnCourt, ndCourt)

ggplot(court, mapping = aes(x=Court, y=courtWins)) + 
  geom_bar(aes(fill = Player), position = "dodge", stat="identity") + 
  ggtitle("Indoor VS Outdoor Wins") + 
  ylab("Wins") + xlab("Court") +
  scale_fill_manual(values=c("#999999", "#56B4E9", "#E69F00"))
```

Let's analyze this plot:

- Roger Federer seems to struggle the least with Indoor courts, having over double the amount of indoor victories than Nadal or Djokovic
- Rafael Nadal wins majority of his matches on Outdoor courts, having the second highest outdoor wins (Nearly passing Federer) while having the lowest Indoor wins.

##### Grand Slam Wins

One of the biggest contributors to the GOAT (Greatest of All Time) status are Grand Slam tournaments. There are four Grand Slam tournaments each year. These four tournaments, are the most prestigious tournaments in tennis and winning the trophy at one of these four tournaments is considered a great achievement. 

- Note, matches after March 2018 are not included in the dataset; this includes Nadal's 2018 French Open victory and Djokovic's 2018 Wimbledon victory. So, within the bounds of this dataset, Nadal has only 16 grand slam wins (He has 17 in reality) and Djokovic has only 12 grand slam wins (he has 13 in reality).

Let's look at the amount of grand slam wins each player has won.

First we need to filter out all tournaments with a series that is not "Grand Slam". 

Then, we need to group by tournament. Afterwards, we can summarize the groups using the n function to get all wins per slam, and add a Player attribute to help us distinguish which player came from which data frame. Then, we bind or combine the three data frames together.

Lastly, we use ggplot to plot a bar graph that displays each player's grand slam wins side by side.

Let's quickly go over why I will use a bar graph for this:

- We will use a bar graph in order to see the relationship between two things: Wins and Player Name
- We want to see which player: Federer, Nadal or Djokovic, had more wins.
- The length of the bars will help us better compare the differences between each player's wins.
- However, our X-Axis is Grand Slam instead of Player Name due to the context of our plot. We want to compare each player's wins in the context of the Grand Slam tournament they were playing. This is why we grouped our data by tournament and made our X-Axis the Grand Slam attribute.

```{r}
rfSlams <- rfMatches %>%
  filter(Winner == "Federer R.") %>%
  filter(Series == "Grand Slam") %>%
  group_by(Tournament) %>%
  summarize(slamWins = n()) %>%
  mutate(Player = "Federer")

rnSlams <- rnMatches %>%
  filter(Winner == "Nadal R.") %>%
  filter(Series == "Grand Slam") %>%
  group_by(Tournament) %>%
  summarize(slamWins = n()) %>%
  mutate(Player = "Nadal")

ndSlams <- ndMatches %>%
  filter(Winner == "Djokovic N.") %>%
  filter(Series == "Grand Slam") %>%
  group_by(Tournament) %>%
  summarize(slamWins = n()) %>%
  mutate(Player = "Djokovic")

slams <- rbind(rfSlams, rnSlams, ndSlams)

ggplot(slams, mapping = aes(x=Tournament, y=slamWins)) + 
  geom_bar(aes(fill = Player), position = "dodge", stat="identity") + 
  ggtitle("Grand Slam Wins") + 
  ylab("Wins") + xlab("Grand Slam") +
  scale_fill_manual(values=c("#999999", "#56B4E9", "#E69F00"))
```

Let's analyze this plot:

- Nadal has the most French Open wins, which makes sense because the French Open is on clay, his favorite surface.
- Federer has the most Wimbledon wins, which makes sense because Wimbledon is on grass, his favorite surface.
- Djokovic is relatively balanced, winning approximately the same amount of matches for each slam.
- Federer has the most wins for 3 out of the four slams, and the most wins overall. This makes sense because he has won the most grand slam titles, and has also been playing the longest.

##### Win Percentage Over Time

So far we've only been looking at wins. However, every player has off days which can lead to losses. Let's look at wins with losses also factored in. We can do this by looking at win percentages. 

Now, the first and more important thing to note is that "Win Percentage" is not an attribute in our dataset. We have to calculate it ourselves.

First, we need to assign each match a value for whether or not it was a victory; 1 for win, 0 for loss. 

Then, we need to group by year. Afterwards, we can use the summarize operation to take the mean of the WonMatch attribute for each group in order to create the winPercentage for that year. We also can take the Season values in order to preserve the Year attribute after our summary collapses the data. 

Then, we can add a Player attribute to help us distinguish which player came from which data frame. Afterwards, we bind the three data frames together.

Lastly, we can use ggplot to plot a line graph that displays each player's win percentage over time.

Let's quickly go over why I will use a line graph for this:

- A line graph allows us to see how a variable performs over time. We can see the particular peaks and valleys of that variable which can allow us to make inferences on its performance.
- In this line graph, we are tracking how the win percentages of each player change over time.

```{r}
rfFinals <- rfMatches %>%
  mutate(WonMatch = ifelse(Winner == "Federer R.", 1, 0)) %>%
  mutate(Season = Year) %>%
  group_by(Year) %>%
  summarize(WinPercentage = mean(WonMatch), Season = median(as.numeric(Season))) %>%
  mutate(Player = "Federer") %>%
  select(Player, Season, WinPercentage)

rnFinals <- rnMatches %>%
  mutate(WonMatch = ifelse(Winner == "Nadal R.", 1, 0)) %>%
  mutate(Season = Year) %>%
  group_by(Year) %>%
  summarize(WinPercentage = mean(WonMatch), Season = median(as.numeric(Season))) %>%
  mutate(Player = "Nadal") %>%
  select(Player, Season, WinPercentage)

ndFinals <- ndMatches %>%
  mutate(WonMatch = ifelse(Winner == "Djokovic N.", 1, 0)) %>%
  mutate(Season = Year) %>%
  group_by(Year) %>%
  summarize(WinPercentage = mean(WonMatch), Season = median(as.numeric(Season))) %>%
  mutate(Player = "Djokovic") %>%
  select(Player, Season, WinPercentage)

finals <- rbind(rfFinals, rnFinals, ndFinals)

ggplot(finals, mapping = aes(x=Season, y=WinPercentage)) + 
  geom_line(aes(color = Player)) + 
  ggtitle("Win Percentage Over Time") + 
  ylab("Win Percentage") + xlab("Year") +
  scale_color_manual(values=c("#999999", "#56B4E9", "#E69F00"))
```

Let's analyze this plot:

- Federer has had 5 different years with over a 0.9 win percentage. (4 if we exclude 2018, which isn't finished yet)
- Djokovic has had 3 different years with over a 0.9 win percentage.
- Nadal only had 1 year with over a 0.9 win percentage
- Federer in 2018 at the time of this dataset's creation is 1.0, since he did not lose a match. In reality, this win percentage goes down because Federer begins losing matches later in the year, which are outside this dataset's time bounds.
- We can see that Federer's win percentage peaked in 2004-2006 and slowly moved downwards, likely due to Nadal (And then later Djokovic) rising through the ranks. He then had a resurgance in 2017 and went back upwards.
- All three players had relatively low win percentages in the early stages of their career, except Djokovic who had a REALLY low win percentage in the early stage of his career. This is because Djokovic was really young in 2004 and started his season towards the end of the year which did not give him many matches.

##### Standardized Win Percentages

Now let's see how the Win Percentages would look if they are standardized. Standardizing simply takes each win percentage value and turns it into a numerical value based on it's variance. Positive numbers are above the mean, while negative numbers are below the mean.

To standardize, we follow this formula:
(winPercentage - meanWinPercentage) / sdPercentage

So first, we need to find the mean and standard deviation of our win percentages. We can do this by using the summarize function and then assigning them to two variables.

Next, we can use mutate to create the standardized win percentage, using the formula above.

Then, we can plot a line graph of the standardized win percentages. Our reasoning for using a line graph is the same as above.

```{r}
newFinals <- finals %>%
  summarize(MeanPercentage = mean(WinPercentage), sdPercentage = sd(WinPercentage))

meanWinPercentage <-newFinals$MeanPercentage
sdPercentage <- newFinals$sdPercentage

standardized <- finals %>%
  mutate(standardizedPercentage = (WinPercentage - meanWinPercentage)/sdPercentage)

ggplot(standardized, mapping = aes(x=Season, y=standardizedPercentage)) + 
  geom_line(aes(color = Player)) + 
  ggtitle("Standardized Win Percentage Over Time") + 
  ylab("Standardized Win Percentage") + xlab("Year") +
  scale_color_manual(values=c("#999999", "#56B4E9", "#E69F00"))
```

Let's briefly analyze this plot:

- Djokovic is the only player who has standardized win percentage below -2
- Federer has four years where he had a standardized win percentage at 1 or above.
- Djokovic only had one year with a standardized win percentage of 1.
- Nadal did not break 1 in terms of standardized win percentages.
- Federer is the only player to have a standardized win percentage greater than 1.
- In general, the line graph looks very similar to the one before; it should because it's the same data.

##### Upsets

Based on these last few plots, we can easily tell that Federer, Nadal and Djokovic in their primes did not lose very often. However, there are certain rare occasions where they get upset by a lower ranked player. Let's take a look at these upsets.

Remember the Match Differential attribute we created earlier? Well now we can finally use it. The match differential is a measure that determines how big of an upset the match was. For big upsets, let's look at all matches with a differential less than or equal to -100.

So let's take each data frame and use filter to get all matches where our player has lost a match with a differential less than or equal to -100. Then, lets bind all three data frames together.

```{r}
rfUpsets <- rfMatches %>%
  filter(Loser == "Federer R.") %>%
  filter(Differential <= -100)

rnUpsets <- rnMatches %>%
  filter(Loser == "Nadal R.") %>%
  filter(Differential <= -100)

ndUpsets <- ndMatches %>%
  filter(Loser == "Djokovic N.") %>%
  filter(Differential <= -100)

upsets <- rbind(rfUpsets, rnUpsets, ndUpsets)
upsets %>% select(Tournament, Year, Winner, Loser, Surface, Round, WRank, LRank, Differential)
```

Let's briefly analyze this table:

- Djokovic seems to get upset the least, having only 5 big upsets, to Nadal's 7 and Federer's 8.
- Nadal has the biggest upset, against Johansson, with a differential of -688, which is way lower than other differentials (The second lowest is -317, which was a match Djokovic lost against Krajinovic)
- I think the most important takeaway is how few upsets there are. Federer, Nadal and Djokovic play hundreds (Over 1000 for Federer) of matches, and only had 8, 7 and 5 big upsets, respectively. This stat is a testament to how consistently good these players are.

Here are the results of our Exploratory Data Analysis:

- Most Top 20 Wins in One Season - Djokovic
- Most Wins on Grass Court - Federer
- Most Wins on Hard Court - Federer
- Most Wins on Clay Court - Nadal
- Most Wins on Indoor Courts - Federer
- Most Australian Open Wins - Federer
- Most French Open Wins - Nadal
- Most Wimbledon Wins - Federer
- Most US Open Wins - Federer
- Highest Win Percentage for One Season - Federer
- Least Upsets - Djokovic
- Most Total Wins - Federer

We can see that Federer's name shows up the most in this list, which partially supports his claim to being the Greatest Of All Time. (He actually is, if we did more analysis, we'd find that his name would show up even more times. The man is truly the greatest of all time, and countless statistics support it). Anyways, it's good to see that our small sample analysis matches and comes to the same conclusion on who is the GOAT.

### WIN PERCENTAGE PER SURFACE
### HIGHEST ELO


### Hypothesis Testing & Machine Learning

Machine learning is making predictions based on the patterns we find in data. For this tutorial, we are going to use something called supervised machine learning. We are going to train a predictor using a training dataset. We then will check how well this predictor predicts by using it on another dataset called the testing dataset. 

The hypothesis we will test is: 

- Will Roger Federer win his next match with Rafael Nadal?

Before we start, we have to look for all matches between Federer and Nadal. 

To do this, we will take all of Federer's matches and use filter to get all matches with Nadal as the winner. Then, we will do it again and get every match with Nadal as the loser. Then we will combine the two data frames. We will only select a few attributes to keep the data relatively clean, like Year, Winner, WElo and LElo, since we're only focused on predicting results. We also need to give each row an ID.

Why Did We Select These Attributes:

- We need the Year to arrange our data in chronological order.
- We need the Winner for obvious reasons (We're predicting winners)
- We need WElo and LElo, the number of games won by the winner and won by the loser, to use as information to help fuel the predictions.

```{r}

fedalMatches <- rfMatches %>%
  filter(Winner == "Nadal R.") 

fedalMatches2 <- rfMatches %>%
  filter(Loser == "Nadal R.") 

fedal <- rbind(fedalMatches, fedalMatches2) %>%
  select(Year, Winner, WElo, LElo) %>%
  arrange(Year)

fedal$ID <- seq.int(nrow(fedal))

fedal

```

Now, we have a dataframe with outcomes for each match. What we need to do next is build a classifier for each outcome based on the predictors. 

First we have to create a Game Differential attribute: 

- It will be essentially Federer's Elo minus Nadal's Elo.
- Matches won by Federer will have Nadal's Elo subtracted from his, plus an extra 250 to simulate the result ELO change
- Matches lost by Federer will have Nadal's Elo subtracted from his, minus an extra 250 to simulate the result ELO change
- The ELO change is meant to simulate the "Mental Advantage" a win over an opponent brings for the next match. In a rivalry that is very even (a win, followed by a loss), this ELO change should even out to have no effect on the predictions. However, in rivalries where a player gets many consecutive over his rival, this ELO change could push the predictions more in the winning player's favor, regardless of their real ELO at the time.
- This differential attribute will help us make predictions
- Likewise, we switched the Winner attribute to a Prediction attribute so that we can better deal with typing.

```{r}

fedalPrepped <- fedal %>%
  mutate(Differential = ifelse(Winner == "Federer R.", 250 + WElo - LElo, -250 + LElo - WElo)) %>%
  mutate(Prediction = ifelse(Differential >= 0, "Federer", "Nadal")) %>%
  dplyr::select(ID, Prediction, Differential)

fedalPrepped$Prediction <- factor(fedalPrepped$Prediction)

fedalPrepped

```

Now, we need to split the prepped data into training and testing subsets. We can use sample_frac to get 25% of this data. 


```{r}
set.seed(9979)

fedalTest <- fedalPrepped %>%
  group_by(Prediction) %>%
  sample_frac(.25) %>%
  ungroup()

fedalTest

fedalTrain <- fedalPrepped %>%
  anti_join(fedalTest, by="ID")

fedalTrain
```

Now that we have our testing and training data prepared, let's use a random forest to train our data. In order to learn what a random forest is, we have to learn what a decision tree is:

Decision trees are used in classification problems where the outcome is categorical (So in our case the categories are: Federer, Nadal). The tree would partition for each categorical prediction into regions, which predict the majority class for training observations within region.

Using a decision tree has several good properties:

- Decision trees are natural constructs, since the outcomes are categorical
- The models are invariant under transformations in the predictor space
- Tree growth is efficient
- Models go after interactions immediately
- Multi-factor responses are easily dealt with

However, there are a couple problems:

- Results can be variable
- Simple trees do not have a lot of predictive power
- Its a greedy algorithm, so the absolute best model may not be found

To solve these problems, We will train over a random forest. A Random Forest is a popular approach to address the shortcomings of singular decision trees by resampling the training data. The goal of a random forest is to improve prediction performance and reduce instability. A random forest averages multiple decision trees that were constructed using a subset of the training data and a subset of the attributes on which to split. So, instead of relying on one decision tree, we are relying on the average of many decision trees. 

To use a random forest, we will use a function from the package "randomForest".

```{r, message=FALSE}
rf <- randomForest(Prediction~., data=fedalTrain %>% dplyr::select(-ID))
rf
```

Let's analyze exactly what these results mean:

- The Random Forest contains 500 trees.
- The estimated error rate is 0%, meaning that the tree wrongly predicted a false positive 0% of the time
- Our forest has correctly predicted Federer as the next winner 12 times
- Our forest has correctly predicted Nadal as the next winner 16 times

So now, we let's make a confusion matrix taking into account both testing and training data. 

```{r}
fedalPredictions <- predict(rf, newdata=fedalTest %>% dplyr::select(-ID))

table(pred=fedalPredictions, observed=fedalTest$Prediction)
```

Let's analyze exactly what these results mean:

- We predict Federer as the winner of the next match 4/9 times
- We predict Nadal as the winner of the next match 5/9 times

##### Takeaway Message For Machine Learning:

In progress
